/*******************************************************************************
*
* Filename:	 main.c
*
* Description:	Progam to generate symbol table C source file which can then be 
*               compiled and included with a build.
*               This program uses the symbols file generated by the GNU nm as
*               input.
*
* $Revision: 1.1 $
*
* $Date: 2013-09-04 08:01:02 $
*
* $Source: /home/cvs/cvsroot/CCT_BIT_2/tools.cct/source/symtbl/main.c,v $
*
* Copyright 2013 Concurrent Technologies, Plc.
*
*******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>


typedef unsigned char	UINT8;
typedef unsigned int	UINT16;
typedef unsigned long	UINT32;
typedef char			INT8;
typedef int				INT16;
typedef long			INT32;
typedef unsigned int	BOOL;



static UINT32 symTotalCount = 0;
static UINT32 symTableCount = 0;

static UINT32 symAbsoluteCount = 0;
static UINT32 symUninitDataCount = 0;
static UINT32 symInitDataCount = 0;
static UINT32 symDebugCount = 0;
static UINT32 symReadOnlyCount = 0;
static UINT32 symTextCount = 0;
static UINT32 symUndefinedCount = 0;
static UINT32 symUnknownCount = 0;


/*******************************************************************************
*
* createHeader
*
* Create and save header information to the output file. 
* 
*
* RETURNS: None.
*
*******************************************************************************/
static void createHeader( FILE *outFp )
{
	fprintf( outFp, "#include \"stdtypes.h\"\n\n" );
	fprintf( outFp, "#include \"symbol.h\"\n\n" );
}



/*******************************************************************************
*
* createExternRefs
*
* Create and save external references to the output file. 
* 
*
* RETURNS: None.
*
*******************************************************************************/
static void createExternRefs( FILE *inFp, FILE *outFp )
{
	UINT32 count;
	UINT32 symAddr;
	char symType;
	char symName[80];
	fpos_t position;
	
	
	count = 0;
	
	fseek( inFp, 0L, SEEK_SET );
	
	while( !feof( inFp ) )
	{
		count++;
		
		fgetpos( inFp, &position );
		
		/* Check line is in the format we want, else ignore */
		symName[0] = '\0';
		fgets( symName, 80, inFp );
		if ( (symName[0] == '\0') || ( !isdigit( symName[0] )) )
		{
			continue;
		}
		
		fsetpos( inFp, &position );
	
		symName[0] = '\0';

		fscanf( inFp, "%lx %c %s", &symAddr, &symType, symName );
		
		if ( strlen(symName) > 0 )
		{
			if ( strchr( symName, '.') == NULL )
			{
				/* printf( "%08lx %c %s\n", symAddr, symType, symName ); */
				
				/* Include global symbols only */
				switch ( symType )
				{
					case 'A': 	/* Symbol is an absolute value */	
					case 'B':	/* Symbol is uninitialized data	*/
					case 'C':	/* Symbol is common (uninitialized data) */
					case 'D':	/* Symbol is initialized data */
					case 'R':	/* Symbol is in a read only data section. */
								
								fprintf( outFp, "extern int %s;\n", symName );
								break;
					
					case 'T': 	/* Symbol is in the text (code) section */
								
								fprintf( outFp, "extern int %s();\n", symName );
								break;
					
					default:	break;	
				}
			}
		}
	}
    
    fputs( "\n", outFp );
    
}


/*******************************************************************************
*
* createSymTable
*
* Create and save symbol table information to the output file. 
* 
*
* RETURNS: None.
*
*******************************************************************************/
static void createSymTable( FILE *inFp, FILE *outFp )
{
	UINT32 count;
	UINT32 symAddr;
	char symType;
	char symName[80];
	fpos_t position;
	
	
	count = 0;
	
	fputs( "SYMBOL symTbl[] = {\n", outFp );
	
	fseek( inFp, 0L, SEEK_SET );
	
	while( !feof( inFp ) )
	{
		count++;
		
		fgetpos( inFp, &position );
		
		/* Check line is in the format we want, else ignore */
		symName[0] = '\0';
		fgets( symName, 80, inFp );
		if ( (symName[0] == '\0') || ( !isdigit( symName[0] )) )
		{
			continue;
		}
		
		fsetpos( inFp, &position );
	
		symName[0] = '\0';

		fscanf( inFp, "%lx %c %s", &symAddr, &symType, symName );
		
		if ( strlen(symName) > 0 )
		{
			if ( strchr( symName, '.') == NULL )
			{
				/* printf( "%08lx %c %s\n", symAddr, symType, symName ); */
				
				symTotalCount++;
				
				/* Update counts */
				switch ( symType )
				{
					case 'A': 	/* Symbol is an absolute value */
								symAbsoluteCount++;
								break;
					
					case 'C':	/* Symbol is common (uninitialized data) */
					case 'B':	/* Symbol is uninitialized data	*/	
					case 'b': 	symUninitDataCount++;
								break;
								
					case 'D':	/* Symbol is initialized data */		
					case 'd': 	symInitDataCount++; 
								break;
								
					case 'N':	/* Debugging symbol */
								symDebugCount++;
								break;
								
					case 'R':	/* Symbol is in a read only data section. */		
					case 'r': 	symReadOnlyCount++; 
								break;
								
					case 'T':	/* Symbol is in the text (code) section */
					case 't':	symTextCount++;
								break;
					
					case 'U':	/* Symbol is undefined */
								symUndefinedCount++;
								break;
								
					default: 	symUnknownCount++;
								/* printf( "Unknown symbol: %08x %c %s\n", symAddr, symType, symName ); */
								break;
				}
				
				/* Include global symbols only in table */
				switch ( symType )
				{
					case 'A': 	/* Symbol is an absolute value */	
					case 'B':	/* Symbol is uninitialized data	*/
					case 'C':	/* Symbol is common (uninitialized data) */
					case 'D':	/* Symbol is initialized data */
					case 'R':	/* Symbol is in a read only data section. */
								symTableCount++;
								
								fprintf( outFp, "    {(char*) &%s, '%c', \"%s\"},\n", 
										symName, symType, symName );
								break;
					
					case 'T': 	/* Symbol is in the text (code) section */
								symTableCount++;
								
								fprintf( outFp, "    {(char*) %s, '%c', \"%s\"},\n", 
										symName, symType, symName );
								break;
					
					default:	break;	
				}
			}
		}
	}
    
    fputs( "};\n", outFp );

	fprintf( outFp, "\nUINT32 symTblSize = %u;\n", symTableCount );    
    
}


/*******************************************************************************
*
* showUsage
*
* Show program usage information. 
* 
*
* RETURNS: None.
*
*******************************************************************************/
static void showUsage( void )
{
	printf("\nUsage: symtbl <input file> <output file>\n");
	
	printf("\nwhere: <input file>  is the file generated by GNU nm.\n");
	printf("       <output file> is the output file created by this program.\n\n");
}


/*******************************************************************************
*
* main
*
* Program entry point. 
* 
*
* RETURNS: None.
*
*******************************************************************************/
int main( int argc, char *argv[] )
{
	FILE *inFp;
	FILE *outFp;
	int result;
	
	
	if (argc != 3)
	{
		showUsage();
		result = 2;
	}
	else
	{	
	    inFp = fopen( argv[1], "r" );
	    
	    if( inFp != NULL ) 
		{
			outFp = fopen( argv[2], "w" );
		
			if( outFp != NULL ) 
			{
				createHeader( outFp );
				
				createExternRefs( inFp, outFp );
				
				createSymTable( inFp, outFp );
				
				if (symTableCount > 0)
				{
					printf("\nSymbols found\n");
					printf("------------------------\n");
					printf("Absolute value    : %lu\n", symAbsoluteCount);
					printf("Uninitialized data: %lu\n", symUninitDataCount);
					printf("Initialized data  : %lu\n", symInitDataCount);
					printf("Debugging         : %lu\n", symDebugCount);
					printf("Read only         : %lu\n", symReadOnlyCount);
					printf("Text (code)       : %lu\n", symTextCount);
					printf("Undefined         : %lu\n", symUndefinedCount);
					printf("Unknown           : %lu\n", symUnknownCount);
					printf("Total             : %lu\n", symTotalCount);
				}
				
				printf("\nSymbol table entries: %lu\n\n", symTableCount ); 
				
				result = 0;
			
				fclose( outFp );
			}
			else
			{
				printf("\nError - failed to open output file: %s\n", argv[2]);
				
				result = 1;
			}
		
			fclose( inFp );
	    }
	    else
	    {
			printf("\nError - failed to open input file: %s\n", argv[1]);
			
			result = 1;
		}
	}
	
	return result;
}
